From c83e0bb76a0671c5b285a853ebea0a26051a2f7e Mon Sep 17 00:00:00 2001
From: Matthew Olson <macslayer@phobos.icl.utk.edu>
Date: Sat, 24 Nov 2018 18:32:52 -0500
Subject: [PATCH] Made initial Flang modifications for SICM

---
 runtime/flang/allo.c      | 1301 +++++++++++++++++++++++++++++++++++--
 runtime/flang/fioMacros.h |   27 +
 runtime/flang/malloc.c    |  123 ++++
 3 files changed, 1414 insertions(+), 37 deletions(-)

diff --git a/runtime/flang/allo.c b/runtime/flang/allo.c
index 3b2a3b34..e2a78475 100644
--- a/runtime/flang/allo.c
+++ b/runtime/flang/allo.c
@@ -31,6 +31,9 @@
 #include "mpalloc.h"
 #include "f90alloc.h"
 
+void *sh_alloc(int id, size_t n);
+void sh_free(void *ptr);
+
 MP_SEMAPHORE(static, sem);
 
 #include "fort_vars.h"
@@ -369,6 +372,140 @@ I8(__fort_alloc)(__INT_T nelem, dtype kind, size_t len, __STAT_T *stat,
   return area;
 }
 
+char *
+I8(__sh_fort_alloc)(int id, __INT_T nelem, dtype kind, size_t len, __STAT_T *stat,
+                 char **pointer, __POINT_T *offset, char *base, int check,
+                 void *(*mallocfn)(int, size_t))
+{
+  ALLO_HDR *p;
+  char *area;
+  size_t need, size, slop, sizeof_hdr;
+  __POINT_T off;
+  char msg[80];
+  char *p_env;
+
+#if (defined(WIN64) || defined(WIN32))
+#define ALN_LARGE
+#else
+#undef ALN_LARGE
+#endif
+/* always use the larger padding   - used be for just win, but
+ * now it makes a bug difference on linux with newer (since Jul 2007)
+ * processor.
+ */
+#define ALN_LARGE
+
+  size_t ALN_MINSZ = 128000;
+  size_t ALN_UNIT = 64;
+  size_t ALN_MAXADJ = 4096;
+
+#define ALN_THRESH (ALN_MAXADJ / ALN_UNIT)
+  static int aln_n = 0;
+  static int env_checked = 0;
+  int myaln;
+
+  sizeof_hdr = AUTOASZ;
+
+  if (!env_checked) {
+    env_checked = 1;
+
+    p_env = getenv("F90_ALN_MINSZ");
+    if (p_env != NULL)
+      ALN_MINSZ = atol(p_env);
+
+    p_env = getenv("F90_ALN_UNIT");
+    if (p_env != NULL)
+      ALN_UNIT = atol(p_env);
+
+    p_env = getenv("F90_ALN_MAXADJ");
+    if (p_env != NULL)
+      ALN_MAXADJ = atol(p_env);
+  }
+
+  ALLHDR();
+
+  if (!ISPRESENT(stat))
+    stat = NULL;
+  if (!ISPRESENT(pointer))
+    pointer = NULL;
+  if (!ISPRESENT(offset))
+    offset = NULL;
+  need = (nelem <= 0) ? 0 : (size_t)nelem * len;
+  slop = 0;
+  /* SLOPPY COMMENT:
+   * here, we add some slop so we can align the eventual
+   * allocated address after adding the size of the ALLO_HDR.
+   * We are going to align to ASZ.  Since we know that the malloc
+   * function returns something at least 8-byte aligned, we only
+   * should have to add (ASZ-8) slop.
+   * Actually, we shouldn't even have to do this if we know
+   * that the malloc function returns aligned results and
+   * skipping ALLO_HDR will keep it aligned */
+  if (nelem > 1 || need > 2 * sizeof_hdr)
+    slop = (offset && len > (ASZ - 8)) ? len : (ASZ - 8);
+  size = (sizeof_hdr + slop + need + ASZ - 1) & ~(ASZ - 1);
+  MP_P(sem);
+  if (size > ALN_MINSZ) {
+    myaln = aln_n;
+    size += ALN_UNIT * myaln;
+    if (aln_n < ALN_THRESH)
+      aln_n++;
+    else
+      aln_n = 0;
+  }
+  p = (size < need) ? NULL : (ALLO_HDR *)mallocfn(id, size);
+  MP_V(sem);
+  if (p == NULL) {
+    if (pointer)
+      *pointer = NULL;
+    if (offset)
+      *offset = 1;
+    if (stat) {
+      *stat = 1;
+      return NULL;
+    }
+    MP_P_STDIO;
+    sprintf(msg, "ALLOCATE: %lu bytes requested; not enough memory", need);
+    MP_V_STDIO;
+    __fort_abort(msg);
+  }
+  if (stat)
+    *stat = 0;
+  area = (char *)p + sizeof_hdr;
+  if (offset) {
+    off = area - base + len - 1;
+    if (kind != __STR && kind != __DERIVED)
+      off >>= GET_DIST_SHIFTS(kind);
+    else
+      off /= len;
+
+    *offset = off + 1;
+    area = base + off * len;
+#if defined(DEBUG)
+    if (__fort_test & DEBUG_ALLO)
+      printf("%d alloc: need %lu size %lu p %p area %p end %p"
+             " base %p offset %ld len %lu\n",
+             GET_DIST_LCPU, need, size, p, area, (char *)p + size - 1, base,
+             *offset, len);
+#endif
+  } else {
+    /* see SLOPPY COMMENT above */
+    if (nelem > 1 || need > 2 * sizeof_hdr)
+      area = ALIGNP(area, ASZ);
+#if defined(DEBUG)
+    if (__fort_test & DEBUG_ALLO)
+      printf("%d alloc: need %lu size %lu p %p area %p end %p\n",
+             GET_DIST_LCPU, need, size, p, area, (char *)p + size - 1);
+#endif
+  }
+  if (size > ALN_MINSZ)
+    area += ALN_UNIT * myaln;
+  XYZZYP(area, p);
+  if (pointer)
+    *pointer = area;
+  return area;
+}
+
 /** \brief
  * allocate space using given 'malloc' function. if present, set
  * pointer and pointer-sized integer offset from base address. offset
@@ -519,23 +656,18 @@ I8(__alloc04)(__NELEM_T nelem, dtype kind, size_t len,
   return area;
 }
 
-/** \brief
- * allocate space using given 'malloc' function. if present, set
- * pointer and pointer-sized integer offset from base address. offset
- * is in units of the data type length.
- */
-char *
-I8(__fort_kalloc)(__INT8_T nelem, dtype kind, size_t len, __STAT_T *stat,
-                  char **pointer, __POINT_T *offset, char *base, int check,
-                  void *(*mallocfn)(size_t))
+static char *
+I8(__sh_alloc04)(int id, __NELEM_T nelem, dtype kind, size_t len,
+               __STAT_T *stat, char **pointer, __POINT_T *offset,
+               char *base, int check, void *(*mallocfn)(int, size_t),
+               size_t align, char *errmsg, int errlen)
 {
   ALLO_HDR *p;
   char *area;
   size_t need, size, slop, sizeof_hdr;
   __POINT_T off;
   char msg[80];
-
-  ALLHDR();
+  char *p_env;
 
   if (!ISPRESENT(stat))
     stat = NULL;
@@ -543,18 +675,73 @@ I8(__fort_kalloc)(__INT8_T nelem, dtype kind, size_t len, __STAT_T *stat,
     pointer = NULL;
   if (!ISPRESENT(offset))
     offset = NULL;
+  if (!ISPRESENT(errmsg))
+    errmsg = NULL;
+
+#if (defined(WIN64) || defined(WIN32))
+#define ALN_LARGE
+#else
+#undef ALN_LARGE
+#endif
+/* always use the larger padding   - used be for just win, but
+ * now it makes a bug difference on linux with newer (since Jul 2007)
+ * processor.
+ */
+#define ALN_LARGE
+
+  size_t ALN_MINSZ = 128000;
+  size_t ALN_UNIT = 64;
+  size_t ALN_MAXADJ = 4096;
+
+#define ALN_THRESH (ALN_MAXADJ / ALN_UNIT)
+  static int aln_n = 0;
+  static int env_checked = 0;
+  int myaln;
 
   sizeof_hdr = AUTOASZ;
 
+  if (!env_checked) {
+    env_checked = 1;
+
+    p_env = getenv("F90_ALN_MINSZ");
+    if (p_env != NULL)
+      ALN_MINSZ = atol(p_env);
+
+    p_env = getenv("F90_ALN_UNIT");
+    if (p_env != NULL)
+      ALN_UNIT = atol(p_env);
+
+    p_env = getenv("F90_ALN_MAXADJ");
+    if (p_env != NULL)
+      ALN_MAXADJ = atol(p_env);
+  }
+
+  ALLHDR();
   need = (nelem <= 0) ? 0 : (size_t)nelem * len;
-  /* see SLOPPY COMMENT above */
+  if (!need) /* should this be size < ASZ ?? */
+    need = ASZ;
   slop = 0;
+  /* SLOPPY COMMENT:
+   * here, we add some slop so we can align the eventual
+   * allocated address after adding the size of the ALLO_HDR.
+   * We are going to align to ASZ.  Since we know that the malloc
+   * function returns something at least 8-byte aligned, we only
+   * should have to add (ASZ-8) slop.
+   * Actually, we shouldn't even have to do this if we know
+   * that the malloc function returns aligned results and
+   * skipping ALLO_HDR will keep it aligned */
   if (nelem > 1 || need > 2 * sizeof_hdr)
-    slop = (offset && len > (ASZ / 2)) ? len : (ASZ / 2);
+    slop = (offset && len > (ASZ - 8)) ? len : (ASZ - 8);
   size = (sizeof_hdr + slop + need + ASZ - 1) & ~(ASZ - 1);
-  MP_P(sem);
-  p = (size < need) ? NULL : (ALLO_HDR *)mallocfn(size);
-  MP_V(sem);
+  if (size > ALN_MINSZ) {
+    myaln = aln_n;
+    size += ALN_UNIT * myaln;
+    if (aln_n < ALN_THRESH)
+      aln_n++;
+    else
+      aln_n = 0;
+  }
+  p = (size < need) ? NULL : (ALLO_HDR *)mallocfn(id, size);
   if (p == NULL) {
     if (pointer)
       *pointer = NULL;
@@ -562,6 +749,16 @@ I8(__fort_kalloc)(__INT8_T nelem, dtype kind, size_t len, __STAT_T *stat,
       *offset = 1;
     if (stat) {
       *stat = 1;
+      if (errmsg) {
+        int i;
+        char *mp;
+        MP_P_STDIO;
+        sprintf(msg, "Not enough memory to allocate %lu bytes", need);
+        mp = msg;
+        for (i = 0; i < errlen; i++)
+          errmsg[i] = (*mp ? *mp++ : ' ');
+        MP_V_STDIO;
+      }
       return NULL;
     }
     MP_P_STDIO;
@@ -569,8 +766,6 @@ I8(__fort_kalloc)(__INT8_T nelem, dtype kind, size_t len, __STAT_T *stat,
     MP_V_STDIO;
     __fort_abort(msg);
   }
-  if (stat)
-    *stat = 0;
   area = (char *)p + sizeof_hdr;
   if (offset) {
     off = area - base + len - 1;
@@ -598,32 +793,198 @@ I8(__fort_kalloc)(__INT8_T nelem, dtype kind, size_t len, __STAT_T *stat,
              GET_DIST_LCPU, need, size, p, area, (char *)p + size - 1);
 #endif
   }
+  if (size > ALN_MINSZ)
+    area += ALN_UNIT * myaln;
+  XYZZYP(area, p);
   if (pointer)
     *pointer = area;
   return area;
 }
 
 /** \brief
- * Is array allocated?
+ * allocate space using given 'malloc' function. if present, set
+ * pointer and pointer-sized integer offset from base address. offset
+ * is in units of the data type length.
  */
-int
-I8(__fort_allocated)(char *area)
+char *
+I8(__fort_kalloc)(__INT8_T nelem, dtype kind, size_t len, __STAT_T *stat,
+                  char **pointer, __POINT_T *offset, char *base, int check,
+                  void *(*mallocfn)(size_t))
 {
   ALLO_HDR *p;
+  char *area;
+  size_t need, size, slop, sizeof_hdr;
+  __POINT_T off;
+  char msg[80];
 
   ALLHDR();
 
-  if (area) {
-    return 1;
-  }
-  return 0;
-}
+  if (!ISPRESENT(stat))
+    stat = NULL;
+  if (!ISPRESENT(pointer))
+    pointer = NULL;
+  if (!ISPRESENT(offset))
+    offset = NULL;
 
-__LOG_T
-I8(ftn_allocated)(char *area)
-{
-  return I8(__fort_allocated)(area) ? GET_DIST_TRUE_LOG : 0;
-}
+  sizeof_hdr = AUTOASZ;
+
+  need = (nelem <= 0) ? 0 : (size_t)nelem * len;
+  /* see SLOPPY COMMENT above */
+  slop = 0;
+  if (nelem > 1 || need > 2 * sizeof_hdr)
+    slop = (offset && len > (ASZ / 2)) ? len : (ASZ / 2);
+  size = (sizeof_hdr + slop + need + ASZ - 1) & ~(ASZ - 1);
+  MP_P(sem);
+  p = (size < need) ? NULL : (ALLO_HDR *)mallocfn(size);
+  MP_V(sem);
+  if (p == NULL) {
+    if (pointer)
+      *pointer = NULL;
+    if (offset)
+      *offset = 1;
+    if (stat) {
+      *stat = 1;
+      return NULL;
+    }
+    MP_P_STDIO;
+    sprintf(msg, "ALLOCATE: %lu bytes requested; not enough memory", need);
+    MP_V_STDIO;
+    __fort_abort(msg);
+  }
+  if (stat)
+    *stat = 0;
+  area = (char *)p + sizeof_hdr;
+  if (offset) {
+    off = area - base + len - 1;
+    if (kind != __STR && kind != __DERIVED)
+      off >>= GET_DIST_SHIFTS(kind);
+    else
+      off /= len;
+
+    *offset = off + 1;
+    area = base + off * len;
+#if defined(DEBUG)
+    if (__fort_test & DEBUG_ALLO)
+      printf("%d alloc: need %lu size %lu p %p area %p end %p"
+             " base %p offset %ld len %lu\n",
+             GET_DIST_LCPU, need, size, p, area, (char *)p + size - 1, base,
+             *offset, len);
+#endif
+  } else {
+    /* see SLOPPY COMMENT above */
+    if (nelem > 1 || need > 2 * sizeof_hdr)
+      area = ALIGNP(area, ASZ);
+#if defined(DEBUG)
+    if (__fort_test & DEBUG_ALLO)
+      printf("%d alloc: need %lu size %lu p %p area %p end %p\n",
+             GET_DIST_LCPU, need, size, p, area, (char *)p + size - 1);
+#endif
+  }
+  if (pointer)
+    *pointer = area;
+  return area;
+}
+
+char *
+I8(__sh_fort_kalloc)(int id, __INT8_T nelem, dtype kind, size_t len, __STAT_T *stat,
+                  char **pointer, __POINT_T *offset, char *base, int check,
+                  void *(*mallocfn)(int, size_t))
+{
+  ALLO_HDR *p;
+  char *area;
+  size_t need, size, slop, sizeof_hdr;
+  __POINT_T off;
+  char msg[80];
+
+  ALLHDR();
+
+  if (!ISPRESENT(stat))
+    stat = NULL;
+  if (!ISPRESENT(pointer))
+    pointer = NULL;
+  if (!ISPRESENT(offset))
+    offset = NULL;
+
+  sizeof_hdr = AUTOASZ;
+
+  need = (nelem <= 0) ? 0 : (size_t)nelem * len;
+  /* see SLOPPY COMMENT above */
+  slop = 0;
+  if (nelem > 1 || need > 2 * sizeof_hdr)
+    slop = (offset && len > (ASZ / 2)) ? len : (ASZ / 2);
+  size = (sizeof_hdr + slop + need + ASZ - 1) & ~(ASZ - 1);
+  MP_P(sem);
+  p = (size < need) ? NULL : (ALLO_HDR *)mallocfn(id, size);
+  MP_V(sem);
+  if (p == NULL) {
+    if (pointer)
+      *pointer = NULL;
+    if (offset)
+      *offset = 1;
+    if (stat) {
+      *stat = 1;
+      return NULL;
+    }
+    MP_P_STDIO;
+    sprintf(msg, "ALLOCATE: %lu bytes requested; not enough memory", need);
+    MP_V_STDIO;
+    __fort_abort(msg);
+  }
+  if (stat)
+    *stat = 0;
+  area = (char *)p + sizeof_hdr;
+  if (offset) {
+    off = area - base + len - 1;
+    if (kind != __STR && kind != __DERIVED)
+      off >>= GET_DIST_SHIFTS(kind);
+    else
+      off /= len;
+
+    *offset = off + 1;
+    area = base + off * len;
+#if defined(DEBUG)
+    if (__fort_test & DEBUG_ALLO)
+      printf("%d alloc: need %lu size %lu p %p area %p end %p"
+             " base %p offset %ld len %lu\n",
+             GET_DIST_LCPU, need, size, p, area, (char *)p + size - 1, base,
+             *offset, len);
+#endif
+  } else {
+    /* see SLOPPY COMMENT above */
+    if (nelem > 1 || need > 2 * sizeof_hdr)
+      area = ALIGNP(area, ASZ);
+#if defined(DEBUG)
+    if (__fort_test & DEBUG_ALLO)
+      printf("%d alloc: need %lu size %lu p %p area %p end %p\n",
+             GET_DIST_LCPU, need, size, p, area, (char *)p + size - 1);
+#endif
+  }
+  if (pointer)
+    *pointer = area;
+  return area;
+}
+
+/** \brief
+ * Is array allocated?
+ */
+int
+I8(__fort_allocated)(char *area)
+{
+  ALLO_HDR *p;
+
+  ALLHDR();
+
+  if (area) {
+    return 1;
+  }
+  return 0;
+}
+
+__LOG_T
+I8(ftn_allocated)(char *area)
+{
+  return I8(__fort_allocated)(area) ? GET_DIST_TRUE_LOG : 0;
+}
 
 __LOG_T
 ENTF90(ALLOCATED, allocated)(char *area)
@@ -858,6 +1219,30 @@ ENTF90(ALLOCA, alloca)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
   }
 }
 
+void
+ENTF90(SH_ALLOCA, sh_alloca)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                       __STAT_T *stat, char **pointer, __POINT_T *offset,
+                       DCHAR(base) DCLEN64(base))
+{
+
+  ALLHDR();
+
+  if (!ISPRESENT(stat)) {
+    void *salp;
+    salp = use_alloc(*nelem, *len);
+    if (salp) {
+      *pointer = salp;
+      return;
+    }
+  }
+  (void)I8(__sh_fort_alloc)(
+      id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset, CADR(base), 1,
+      LOCAL_MODE ? __sh_fort_malloc_without_abort : __sh_fort_gmalloc_without_abort);
+  if (!ISPRESENT(stat)) {
+    save_alloc(*nelem, *len, pointer);
+  }
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(ALLOC, alloc)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
@@ -868,6 +1253,15 @@ ENTF90(ALLOC, alloc)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                          (__CLEN_T)CLEN(base));
 }
 
+void
+ENTF90(SH_ALLOC, sh_alloc)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                     __STAT_T *stat, char **pointer, __POINT_T *offset,
+                     DCHAR(base) DCLEN(base))
+{
+  ENTF90(sh_ALLOCA, sh_alloca)(id, nelem, kind, len, stat, pointer, offset, CADR(base),
+                         (__CLEN_T)CLEN(base));
+}
+
 void
 ENTF90(ALLOC03A, alloc03a)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                          __STAT_T *stat, char **pointer, __POINT_T *offset,
@@ -895,6 +1289,33 @@ ENTF90(ALLOC03A, alloc03a)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
   }
 }
 
+void
+ENTF90(SH_ALLOC03A, sh_alloc03a)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                         __STAT_T *stat, char **pointer, __POINT_T *offset,
+                         __INT_T *firsttime, DCHAR(errmsg) DCLEN64(errmsg))
+{
+  ALLHDR();
+
+  if (ISPRESENT(stat) && *firsttime)
+    *stat = 0;
+
+  if (!ISPRESENT(stat)) {
+    void *salp;
+    salp = use_alloc(*nelem, *len);
+    if (salp) {
+      *pointer = salp;
+      return;
+    }
+  }
+  (void)I8(__sh_alloc04)(id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset,
+                      0, 1, LOCAL_MODE ? __sh_fort_malloc_without_abort
+                                       : __sh_fort_gmalloc_without_abort,
+                      0, CADR(errmsg), CLEN(errmsg));
+  if (!ISPRESENT(stat)) {
+    save_alloc(*nelem, *len, pointer);
+  }
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(ALLOC03, alloc03)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
@@ -905,6 +1326,15 @@ ENTF90(ALLOC03, alloc03)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                              firsttime, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_ALLOC03, sh_alloc03)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                         __STAT_T *stat, char **pointer, __POINT_T *offset,
+                         __INT_T *firsttime, DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_ALLOC03A, sh_alloc03a)(id, nelem, kind, len, stat, pointer, offset,
+                             firsttime, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 void
 ENTF90(ALLOC03_CHKA, alloc03_chka)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                          __STAT_T *stat, char **pointer, __POINT_T *offset,
@@ -918,6 +1348,19 @@ ENTF90(ALLOC03_CHKA, alloc03_chka)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                             firsttime,CADR(errmsg), CLEN(errmsg));
 }
 
+void
+ENTF90(SH_ALLOC03_CHKA, sh_alloc03_chka)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                         __STAT_T *stat, char **pointer, __POINT_T *offset,
+                         __INT_T *firsttime, DCHAR(errmsg) DCLEN64(errmsg))
+{
+
+  if (*pointer && I8(__fort_allocated)(*pointer)) {
+    __fort_abort("ALLOCATE: array already allocated");
+  }
+  ENTF90(SH_ALLOC03,sh_alloc03)(id, nelem, kind, len, stat, pointer, offset,
+                            firsttime,CADR(errmsg), CLEN(errmsg));
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(ALLOC03_CHK, alloc03_chk)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
@@ -929,6 +1372,16 @@ ENTF90(ALLOC03_CHK, alloc03_chk)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                          firsttime, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_ALLOC03_CHK, sh_alloc03_chk)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                         __STAT_T *stat, char **pointer, __POINT_T *offset,
+                         __INT_T *firsttime, DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_ALLOC03_CHKA, sh_alloc03_chka)(id, nelem, kind, len,
+                         stat, pointer, offset,
+                         firsttime, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 void
 ENTF90(ALLOC04A, alloc04a)(__NELEM_T *nelem, __INT_T *kind, __INT_T *len,
                          __STAT_T *stat, char **pointer, __POINT_T *offset,
@@ -957,6 +1410,34 @@ ENTF90(ALLOC04A, alloc04a)(__NELEM_T *nelem, __INT_T *kind, __INT_T *len,
   }
 }
 
+void
+ENTF90(SH_ALLOC04A, sh_alloc04a)(int id, __NELEM_T *nelem, __INT_T *kind, __INT_T *len,
+                         __STAT_T *stat, char **pointer, __POINT_T *offset,
+                         __INT_T *firsttime, __NELEM_T *align,
+                         DCHAR(errmsg) DCLEN64(errmsg))
+{
+  ALLHDR();
+
+  if (ISPRESENT(stat) && *firsttime)
+    *stat = 0;
+
+  if (!ISPRESENT(stat) && !*align) {
+    void *salp;
+    salp = use_alloc(*nelem, *len);
+    if (salp) {
+      *pointer = salp;
+      return;
+    }
+  }
+  (void)I8(__sh_alloc04)(id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset,
+                      0, 1, LOCAL_MODE ? __sh_fort_malloc_without_abort
+                                       : __sh_fort_gmalloc_without_abort,
+                      *align, CADR(errmsg), CLEN(errmsg));
+  if (!ISPRESENT(stat)) {
+    save_alloc(*nelem, *len, pointer);
+  }
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(ALLOC04, alloc04)(__NELEM_T *nelem, __INT_T *kind, __INT_T *len,
@@ -968,6 +1449,16 @@ ENTF90(ALLOC04, alloc04)(__NELEM_T *nelem, __INT_T *kind, __INT_T *len,
 			   align, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_ALLOC04, sh_alloc04)(int id, __NELEM_T *nelem, __INT_T *kind, __INT_T *len,
+                         __STAT_T *stat, char **pointer, __POINT_T *offset,
+                         __INT_T *firsttime, __NELEM_T *align,
+                         DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_ALLOC04A, sh_alloc04a)(id, nelem, kind, len, stat, pointer, offset, firsttime, 
+			   align, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 void
 ENTF90(ALLOC04_CHKA, alloc04_chka)(__NELEM_T *nelem, __INT_T *kind,
                                  __INT_T *len, __STAT_T *stat,
@@ -983,6 +1474,21 @@ ENTF90(ALLOC04_CHKA, alloc04_chka)(__NELEM_T *nelem, __INT_T *kind,
            align, CADR(errmsg), CLEN(errmsg));
 }
 
+void
+ENTF90(SH_ALLOC04_CHKA, sh_alloc04_chka)(int id, __NELEM_T *nelem, __INT_T *kind,
+                                 __INT_T *len, __STAT_T *stat,
+                                 char **pointer, __POINT_T *offset,
+                                 __INT_T *firsttime, __NELEM_T *align,
+                                 DCHAR(errmsg) DCLEN64(errmsg))
+{
+
+  if (*pointer && I8(__fort_allocated)(*pointer)) {
+    __fort_abort("ALLOCATE: array already allocated");
+  }
+  ENTF90(SH_ALLOC04,sh_alloc04)(id, nelem, kind, len, stat, pointer, offset, firsttime,
+           align, CADR(errmsg), CLEN(errmsg));
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(ALLOC04_CHK, alloc04_chk)(__NELEM_T *nelem, __INT_T *kind,
@@ -995,6 +1501,17 @@ ENTF90(ALLOC04_CHK, alloc04_chk)(__NELEM_T *nelem, __INT_T *kind,
                                      firsttime, align, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_ALLOC04_CHK, sh_alloc04_chk)(int id, __NELEM_T *nelem, __INT_T *kind,
+                                 __INT_T *len, __STAT_T *stat,
+                                 char **pointer, __POINT_T *offset,
+                                 __INT_T *firsttime, __NELEM_T *align,
+                                 DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_ALLOC04_CHKA, sh_alloc04_chka)(id, nelem, kind, len, stat, pointer, offset,
+                                     firsttime, align, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 void
 ENTF90(KALLOC, kalloc)(__INT8_T *nelem, __INT_T *kind, __INT_T *len,
                        __STAT_T *stat, char **pointer, __POINT_T *offset,
@@ -1016,6 +1533,27 @@ ENTF90(KALLOC, kalloc)(__INT8_T *nelem, __INT_T *kind, __INT_T *len,
   }
 }
 
+void
+ENTF90(SH_KALLOC, sh_kalloc)(int id, __INT8_T *nelem, __INT_T *kind, __INT_T *len,
+                       __STAT_T *stat, char **pointer, __POINT_T *offset,
+                       DCHAR(base) DCLEN(base))
+{
+  if (!ISPRESENT(stat)) {
+    void *salp;
+    salp = use_alloc(*nelem, *len);
+    if (salp) {
+      *pointer = salp;
+      return;
+    }
+  }
+  (void)I8(__sh_fort_kalloc)(
+      id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset, CADR(base), 1,
+      LOCAL_MODE ? __sh_fort_malloc_without_abort : __sh_fort_gmalloc_without_abort);
+  if (!ISPRESENT(stat)) {
+    save_alloc(*nelem, *len, pointer);
+  }
+}
+
 void
 ENTF90(CALLOC, calloc)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                        __STAT_T *stat, char **pointer, __POINT_T *offset,
@@ -1026,6 +1564,16 @@ ENTF90(CALLOC, calloc)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
       LOCAL_MODE ? __fort_calloc_without_abort : __fort_gcalloc_without_abort);
 }
 
+void
+ENTF90(SH_CALLOC, sh_calloc)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                       __STAT_T *stat, char **pointer, __POINT_T *offset,
+                       DCHAR(base) DCLEN(base))
+{
+  (void)I8(__sh_fort_alloc)(
+      id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset, CADR(base), 1,
+      LOCAL_MODE ? __sh_fort_calloc_without_abort : __sh_fort_gcalloc_without_abort);
+}
+
 void
 ENTF90(CALLOC03A, calloc03a)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                            __STAT_T *stat, char **pointer,
@@ -1041,6 +1589,21 @@ ENTF90(CALLOC03A, calloc03a)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                       0, CADR(errmsg), CLEN(errmsg));
 }
 
+void
+ENTF90(SH_CALLOC03A, sh_calloc03a)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                           __STAT_T *stat, char **pointer,
+                           __POINT_T *offset, __INT_T *firsttime,
+                           DCHAR(errmsg) DCLEN64(errmsg))
+{
+  if (ISPRESENT(stat) && *firsttime)
+    *stat = 0;
+
+  (void)I8(__sh_alloc04)(id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset,
+                      0, 1, LOCAL_MODE ? __sh_fort_calloc_without_abort
+                                       : __sh_fort_gcalloc_without_abort,
+                      0, CADR(errmsg), CLEN(errmsg));
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(CALLOC03, calloc03)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
@@ -1054,6 +1617,18 @@ ENTF90(CALLOC03, calloc03)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                            CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_CALLOC03, sh_calloc03)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                           __STAT_T *stat, char **pointer,
+                           __POINT_T *offset, __INT_T *firsttime,
+                           DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_CALLOC03A, sh_calloc03a)(id, nelem, kind, len,
+                           stat, pointer,
+                           offset, firsttime,
+                           CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 void
 ENTF90(CALLOC04A, calloc04a)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                            __STAT_T *stat, char **pointer,
@@ -1069,14 +1644,41 @@ ENTF90(CALLOC04A, calloc04a)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                       *align, CADR(errmsg), CLEN(errmsg));
 }
 
+void
+ENTF90(SH_CALLOC04A, sh_calloc04a)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                           __STAT_T *stat, char **pointer,
+                           __POINT_T *offset, __INT_T *firsttime,
+                           __NELEM_T *align, DCHAR(errmsg) DCLEN64(errmsg))
+{
+  if (ISPRESENT(stat) && *firsttime)
+    *stat = 0;
+
+  (void)I8(__sh_alloc04)(id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset,
+                      0, 1, LOCAL_MODE ? __sh_fort_calloc_without_abort
+                                       : __sh_fort_gcalloc_without_abort,
+                      *align, CADR(errmsg), CLEN(errmsg));
+}
+
 /* 32 bit CLEN version */
 void
-ENTF90(CALLOC04, calloc04)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
+ENTF90(CALLOC04, calloc04)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
+                           __STAT_T *stat, char **pointer,
+                           __POINT_T *offset, __INT_T *firsttime,
+                           __NELEM_T *align, DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(CALLOC04A, calloc04a)(nelem, kind, len,
+                           stat, pointer,
+                           offset, firsttime,
+                           align, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
+void
+ENTF90(SH_CALLOC04, sh_calloc04)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
                            __STAT_T *stat, char **pointer,
                            __POINT_T *offset, __INT_T *firsttime,
                            __NELEM_T *align, DCHAR(errmsg) DCLEN(errmsg))
 {
-  ENTF90(CALLOC04A, calloc04a)(nelem, kind, len,
+  ENTF90(SH_CALLOC04A, sh_calloc04a)(id, nelem, kind, len,
                            stat, pointer,
                            offset, firsttime,
                            align, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
@@ -1092,6 +1694,16 @@ ENTF90(KCALLOC, kcalloc)(__INT8_T *nelem, __INT_T *kind, __INT_T *len,
       LOCAL_MODE ? __fort_calloc_without_abort : __fort_gcalloc_without_abort);
 }
 
+void
+ENTF90(SH_KCALLOC, sh_kcalloc)(int id, __INT8_T *nelem, __INT_T *kind, __INT_T *len,
+                         __STAT_T *stat, char **pointer, __POINT_T *offset,
+                         DCHAR(base) DCLEN(base))
+{
+  (void)I8(__sh_fort_kalloc)(
+      id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset, CADR(base), 1,
+      LOCAL_MODE ? __sh_fort_calloc_without_abort : __sh_fort_gcalloc_without_abort);
+}
+
 /** \brief
  * F90 allocate statement -- don't check allocated status
  */
@@ -1105,6 +1717,16 @@ ENTF90(PTR_ALLOCA, ptr_alloca)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
       LOCAL_MODE ? __fort_malloc_without_abort : __fort_gmalloc_without_abort);
 }
 
+void
+ENTF90(SH_PTR_ALLOCA, sh_ptr_alloca)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                             __STAT_T *stat, char **pointer,
+                             __POINT_T *offset, DCHAR(base) DCLEN64(base))
+{
+  (void)I8(__sh_fort_alloc)(
+      id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset, CADR(base), 0,
+      LOCAL_MODE ? __sh_fort_malloc_without_abort : __sh_fort_gmalloc_without_abort);
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(PTR_ALLOC, ptr_alloc)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
@@ -1116,6 +1738,16 @@ ENTF90(PTR_ALLOC, ptr_alloc)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                              offset, CADR(base), (__CLEN_T)CLEN(base));
 }
 
+void
+ENTF90(SH_PTR_ALLOC, sh_ptr_alloc)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                             __STAT_T *stat, char **pointer,
+                             __POINT_T *offset, DCHAR(base) DCLEN(base))
+{
+  ENTF90(SH_PTR_ALLOCA, sh_ptr_alloca)(id, nelem, kind, len,
+                             stat, pointer,
+                             offset, CADR(base), (__CLEN_T)CLEN(base));
+}
+
 /** \brief
  * F90 allocate statement -- don't check allocated status
  */
@@ -1132,6 +1764,20 @@ ENTF90(PTR_ALLOC03A, ptr_alloc03a)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                                        : __fort_gmalloc_without_abort,
                       0, CADR(errmsg), CLEN(errmsg));
 }
+
+void
+ENTF90(SH_PTR_ALLOC03A, sh_ptr_alloc03a)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                         __STAT_T *stat, char **pointer, __POINT_T *offset,
+                         __INT_T *firsttime, DCHAR(errmsg) DCLEN64(errmsg))
+{
+  if (ISPRESENT(stat) && *firsttime)
+    *stat = 0;
+
+  (void)I8(__sh_alloc04)(id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset,
+                      0, 0, LOCAL_MODE ? __sh_fort_malloc_without_abort
+                                       : __sh_fort_gmalloc_without_abort,
+                      0, CADR(errmsg), CLEN(errmsg));
+}
 /* 32 bit CLEN version */
 void
 ENTF90(PTR_ALLOC03, ptr_alloc03)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
@@ -1143,6 +1789,16 @@ ENTF90(PTR_ALLOC03, ptr_alloc03)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                          firsttime, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_ALLOC03, sh_ptr_alloc03)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                         __STAT_T *stat, char **pointer, __POINT_T *offset,
+                         __INT_T *firsttime, DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_PTR_ALLOC03A, sh_ptr_alloc03a)(id, nelem, kind, len,
+                         stat, pointer, offset,
+                         firsttime, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 void
 ENTF90(PTR_ALLOC04A, ptr_alloc04a)(__NELEM_T *nelem, __INT_T *kind,
                                  __INT_T *len, __STAT_T *stat,
@@ -1159,6 +1815,22 @@ ENTF90(PTR_ALLOC04A, ptr_alloc04a)(__NELEM_T *nelem, __INT_T *kind,
                       *align, CADR(errmsg), CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_ALLOC04A, sh_ptr_alloc04a)(int id, __NELEM_T *nelem, __INT_T *kind,
+                                 __INT_T *len, __STAT_T *stat,
+                                 char **pointer, __POINT_T *offset,
+                                 __INT_T *firsttime, __NELEM_T *align,
+                                 DCHAR(errmsg) DCLEN64(errmsg))
+{
+  if (ISPRESENT(stat) && *firsttime)
+    *stat = 0;
+
+  (void)I8(__sh_alloc04)(id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset,
+                      0, 0, LOCAL_MODE ? __sh_fort_malloc_without_abort
+                                       : __sh_fort_gmalloc_without_abort,
+                      *align, CADR(errmsg), CLEN(errmsg));
+}
+
 void
 ENTF90(PTR_ALLOC04, ptr_alloc04)(__NELEM_T *nelem, __INT_T *kind,
                                  __INT_T *len, __STAT_T *stat,
@@ -1173,6 +1845,20 @@ ENTF90(PTR_ALLOC04, ptr_alloc04)(__NELEM_T *nelem, __INT_T *kind,
                                  CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_ALLOC04, sh_ptr_alloc04)(int id, __NELEM_T *nelem, __INT_T *kind,
+                                 __INT_T *len, __STAT_T *stat,
+                                 char **pointer, __POINT_T *offset,
+                                 __INT_T *firsttime, __NELEM_T *align,
+                                 DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_PTR_ALLOC04A, sh_ptr_alloc04a)(id, nelem, kind,
+                                 len, stat,
+                                 pointer, offset,
+                                 firsttime, align,
+                                 CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 /** \brief
  *  Same as ptr_alloc03 above, except it's used with sourced allocation where
  *  the destination or source argument is polymorphic. So, we neeed to get
@@ -1203,6 +1889,30 @@ ENTF90(PTR_SRC_ALLOC03A, ptr_src_alloc03a)(F90_Desc *sd, __INT_T *nelem,
                       0, CADR(errmsg), CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_SRC_ALLOC03A, sh_ptr_src_alloc03a)(int id, F90_Desc *sd, __INT_T *nelem,
+                             __INT_T *kind, __INT_T *len, __STAT_T *stat,
+                             char **pointer, __POINT_T *offset,
+                             __INT_T *firsttime, DCHAR(errmsg) DCLEN64(errmsg))
+{
+  __INT_T src_len, max_len;
+
+  src_len = ENTF90(GET_OBJECT_SIZE, get_object_size)(sd);
+  if (sd && sd->tag == __DESC && sd->lsize > 1)
+    src_len *= sd->lsize;
+  max_len = (len && nelem) ? (*len * *nelem) : 0;
+  if (max_len < src_len)
+    max_len = src_len;
+
+  if (ISPRESENT(stat) && firsttime && *firsttime)
+    *stat = 0;
+
+  (void)I8(__sh_alloc04)(id, *nelem, (dtype)*kind, (size_t)max_len, stat, pointer,
+                      offset, 0, 0, LOCAL_MODE ? __sh_fort_malloc_without_abort
+                                               : __sh_fort_gmalloc_without_abort,
+                      0, CADR(errmsg), CLEN(errmsg));
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(PTR_SRC_ALLOC03, ptr_src_alloc03)(F90_Desc *sd, __INT_T *nelem,
@@ -1216,6 +1926,18 @@ ENTF90(PTR_SRC_ALLOC03, ptr_src_alloc03)(F90_Desc *sd, __INT_T *nelem,
                              firsttime, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_SRC_ALLOC03, sh_ptr_src_alloc03)(int id, F90_Desc *sd, __INT_T *nelem,
+                             __INT_T *kind, __INT_T *len, __STAT_T *stat,
+                             char **pointer, __POINT_T *offset,
+                             __INT_T *firsttime, DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_PTR_SRC_ALLOC03A, sh_ptr_src_alloc03a)(id, sd, nelem,
+                             kind, len, stat,
+                             pointer, offset,
+                             firsttime, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 void
 ENTF90(PTR_SRC_CALLOC03A, ptr_src_calloc03a)(F90_Desc *sd, __INT_T *nelem,
                               __INT_T *kind, __INT_T *len, __STAT_T *stat,
@@ -1240,6 +1962,30 @@ ENTF90(PTR_SRC_CALLOC03A, ptr_src_calloc03a)(F90_Desc *sd, __INT_T *nelem,
                       0, CADR(errmsg), CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_SRC_CALLOC03A, sh_ptr_src_calloc03a)(int id, F90_Desc *sd, __INT_T *nelem,
+                              __INT_T *kind, __INT_T *len, __STAT_T *stat,
+                              char **pointer, __POINT_T *offset,
+                             __INT_T *firsttime, DCHAR(errmsg) DCLEN64(errmsg))
+{
+  __INT_T src_len, max_len;
+
+  src_len = ENTF90(GET_OBJECT_SIZE, get_object_size)(sd);
+  if (sd && sd->tag == __DESC && sd->lsize > 1)
+    src_len *= sd->lsize;
+  max_len = (len && nelem) ? (*len * *nelem) : 0;
+  if (max_len < src_len)
+    max_len = src_len;
+
+  if (ISPRESENT(stat) && firsttime && *firsttime)
+    *stat = 0;
+
+  (void)I8(__sh_alloc04)(id, *nelem, (dtype)*kind, (size_t)max_len, stat, pointer,
+                      offset, 0, 0, LOCAL_MODE ? __sh_fort_calloc_without_abort
+                                               : __sh_fort_gcalloc_without_abort,
+                      0, CADR(errmsg), CLEN(errmsg));
+}
+
 void
 ENTF90(PTR_SRC_CALLOC03, ptr_src_calloc03)(F90_Desc *sd, __INT_T *nelem,
                               __INT_T *kind, __INT_T *len, __STAT_T *stat,
@@ -1252,6 +1998,18 @@ ENTF90(PTR_SRC_CALLOC03, ptr_src_calloc03)(F90_Desc *sd, __INT_T *nelem,
                              firsttime, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_SRC_CALLOC03, sh_ptr_src_calloc03)(int id, F90_Desc *sd, __INT_T *nelem,
+                              __INT_T *kind, __INT_T *len, __STAT_T *stat,
+                              char **pointer, __POINT_T *offset,
+                             __INT_T *firsttime, DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_PTR_SRC_CALLOC03A, sh_ptr_src_calloc03a)(id, sd, nelem,
+                              kind, len, stat,
+                              pointer, offset,
+                             firsttime, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 void
 ENTF90(PTR_SRC_ALLOC04A, ptr_src_alloc04a)(F90_Desc *sd, __NELEM_T *nelem,
                              __INT_T *kind, __INT_T *len, __STAT_T *stat,
@@ -1277,6 +2035,31 @@ ENTF90(PTR_SRC_ALLOC04A, ptr_src_alloc04a)(F90_Desc *sd, __NELEM_T *nelem,
                       *align, CADR(errmsg), CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_SRC_ALLOC04A, sh_ptr_src_alloc04a)(int id, F90_Desc *sd, __NELEM_T *nelem,
+                             __INT_T *kind, __INT_T *len, __STAT_T *stat,
+                             char **pointer, __POINT_T *offset,
+                             __INT_T *firsttime, __NELEM_T *align,
+                             DCHAR(errmsg) DCLEN64(errmsg))
+{
+  __INT_T src_len, max_len;
+
+  src_len = ENTF90(GET_OBJECT_SIZE, get_object_size)(sd);
+  if (sd && sd->tag == __DESC && sd->lsize > 1)
+    src_len *= sd->lsize;
+  max_len = (len && nelem) ? (*len * *nelem) : 0;
+  if (max_len < src_len)
+    max_len = src_len;
+
+  if (ISPRESENT(stat) && firsttime && *firsttime)
+    *stat = 0;
+
+  (void)I8(__sh_alloc04)(id, *nelem, (dtype)*kind, (size_t)max_len, stat, pointer,
+                      offset, 0, 0, LOCAL_MODE ? __sh_fort_malloc_without_abort
+                                               : __sh_fort_gmalloc_without_abort,
+                      *align, CADR(errmsg), CLEN(errmsg));
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(PTR_SRC_ALLOC04, ptr_src_alloc04)(F90_Desc *sd, __NELEM_T *nelem,
@@ -1292,6 +2075,20 @@ ENTF90(PTR_SRC_ALLOC04, ptr_src_alloc04)(F90_Desc *sd, __NELEM_T *nelem,
                              CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_SRC_ALLOC04, sh_ptr_src_alloc04)(int id, F90_Desc *sd, __NELEM_T *nelem,
+                             __INT_T *kind, __INT_T *len, __STAT_T *stat,
+                             char **pointer, __POINT_T *offset,
+                             __INT_T *firsttime, __NELEM_T *align,
+                             DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_PTR_SRC_ALLOC04A, sh_ptr_src_alloc04a)(id, sd, nelem,
+                             kind, len, stat,
+                             pointer, offset,
+                             firsttime, align,
+                             CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 void
 ENTF90(PTR_SRC_CALLOC04A, ptr_src_calloc04a)
                              (F90_Desc *sd, __NELEM_T *nelem, __INT_T *kind,
@@ -1323,6 +2120,37 @@ ENTF90(PTR_SRC_CALLOC04A, ptr_src_calloc04a)
                       *align, CADR(errmsg), CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_SRC_CALLOC04A, sh_ptr_src_calloc04a)
+                             (int id, F90_Desc *sd, __NELEM_T *nelem, __INT_T *kind,
+                              __INT_T *len, __STAT_T *stat, char **pointer,
+                              __POINT_T *offset, __INT_T *firsttime,
+                              __NELEM_T *align, DCHAR(errmsg) DCLEN64(errmsg))
+{
+  __INT_T src_len, max_len;
+
+  src_len = ENTF90(GET_OBJECT_SIZE, get_object_size)(sd);
+  if (sd && sd->tag == __DESC) {
+    if (sd->lsize > 1) {
+      src_len *= sd->lsize;
+    } else if (!sd->rank && !sd->lsize && !sd->gsize && sd->len > 0 &&
+               sd->kind > 0 && sd->kind <= __NTYPES) {
+      src_len = sd->len;
+    }
+  }
+  max_len = (len && nelem) ? (*len * *nelem) : 0;
+  if (max_len < src_len)
+    max_len = src_len;
+
+  if (ISPRESENT(stat) && firsttime && *firsttime)
+    *stat = 0;
+
+  (void)I8(__sh_alloc04)(id, *nelem, (dtype)*kind, (size_t)max_len, stat, pointer,
+                      offset, 0, 0, LOCAL_MODE ? __sh_fort_calloc_without_abort
+                                               : __sh_fort_gcalloc_without_abort,
+                      *align, CADR(errmsg), CLEN(errmsg));
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(PTR_SRC_CALLOC04, ptr_src_calloc04)
@@ -1337,6 +2165,19 @@ ENTF90(PTR_SRC_CALLOC04, ptr_src_calloc04)
                               align, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_SRC_CALLOC04, sh_ptr_src_calloc04)
+                             (int id, F90_Desc *sd, __NELEM_T *nelem, __INT_T *kind,
+                              __INT_T *len, __STAT_T *stat, char **pointer,
+                              __POINT_T *offset, __INT_T *firsttime,
+                              __NELEM_T *align, DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_PTR_SRC_CALLOC04A, sh_ptr_src_calloc04a)(id, sd, nelem, kind,
+                              len, stat, pointer,
+                              offset, firsttime,
+                              align, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 /** \brief
  * 64 bit F90 allocate statement -- don't check allocated status
  */
@@ -1351,6 +2192,17 @@ ENTF90(PTR_KALLOC, ptr_kalloc)(__INT8_T *nelem, __INT_T *kind,
       LOCAL_MODE ? __fort_malloc_without_abort : __fort_gmalloc_without_abort);
 }
 
+void
+ENTF90(SH_PTR_KALLOC, sh_ptr_kalloc)(int id, __INT8_T *nelem, __INT_T *kind,
+                               __INT_T *len, __STAT_T *stat,
+                               char **pointer, __POINT_T *offset,
+                               DCHAR(base) DCLEN(base))
+{
+  (void)I8(__sh_fort_kalloc)(
+      id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset, CADR(base), 0,
+      LOCAL_MODE ? __sh_fort_malloc_without_abort : __sh_fort_gmalloc_without_abort);
+}
+
 void
 ENTF90(PTR_CALLOC, ptr_calloc)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
                                __STAT_T *stat, char **pointer,
@@ -1361,6 +2213,16 @@ ENTF90(PTR_CALLOC, ptr_calloc)(__INT_T *nelem, __INT_T *kind, __INT_T *len,
       LOCAL_MODE ? __fort_calloc_without_abort : __fort_gcalloc_without_abort);
 }
 
+void
+ENTF90(SH_PTR_CALLOC, sh_ptr_calloc)(int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                               __STAT_T *stat, char **pointer,
+                               __POINT_T *offset, DCHAR(base) DCLEN(base))
+{
+  (void)I8(__sh_fort_alloc)(
+      id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset, CADR(base), 0,
+      LOCAL_MODE ? __sh_fort_calloc_without_abort : __sh_fort_gcalloc_without_abort);
+}
+
 void
 ENTF90(PTR_CALLOC03A, ptr_calloc03a)
                          (__INT_T *nelem, __INT_T *kind, __INT_T *len,
@@ -1376,6 +2238,21 @@ ENTF90(PTR_CALLOC03A, ptr_calloc03a)
                       0, CADR(errmsg), CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_CALLOC03A, sh_ptr_calloc03a)
+                         (int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                          __STAT_T *stat, char **pointer, __POINT_T *offset,
+                          __INT_T *firsttime, DCHAR(errmsg) DCLEN64(errmsg))
+{
+  if (ISPRESENT(stat) && *firsttime)
+    *stat = 0;
+
+  (void)I8(__sh_alloc04)(id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset,
+                      0, 0, LOCAL_MODE ? __sh_fort_calloc_without_abort
+                                       : __sh_fort_gcalloc_without_abort,
+                      0, CADR(errmsg), CLEN(errmsg));
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(PTR_CALLOC03, ptr_calloc03)
@@ -1388,6 +2265,17 @@ ENTF90(PTR_CALLOC03, ptr_calloc03)
                           firsttime, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_CALLOC03, sh_ptr_calloc03)
+                         (int id, __INT_T *nelem, __INT_T *kind, __INT_T *len,
+                          __STAT_T *stat, char **pointer, __POINT_T *offset,
+                          __INT_T *firsttime, DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_PTR_CALLOC03A, sh_ptr_calloc03a)(id, nelem, kind, len,
+                          stat, pointer, offset,
+                          firsttime, CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 void
 ENTF90(PTR_CALLOC04A, ptr_calloc04a)(__NELEM_T *nelem, __INT_T *kind,
                                    __INT_T *len, __STAT_T *stat,
@@ -1404,6 +2292,22 @@ ENTF90(PTR_CALLOC04A, ptr_calloc04a)(__NELEM_T *nelem, __INT_T *kind,
                       *align, CADR(errmsg), CLEN(errmsg));
 }
 
+void
+ENTF90(SH_PTR_CALLOC04A, sh_ptr_calloc04a)(int id, __NELEM_T *nelem, __INT_T *kind,
+                                   __INT_T *len, __STAT_T *stat,
+                                   char **pointer, __POINT_T *offset,
+                                   __INT_T *firsttime, __NELEM_T *align,
+                                   DCHAR(errmsg) DCLEN64(errmsg))
+{
+  if (ISPRESENT(stat) && *firsttime)
+    *stat = 0;
+
+  (void)I8(__sh_alloc04)(id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset,
+                      0, 0, LOCAL_MODE ? __sh_fort_calloc_without_abort
+                                       : __sh_fort_gcalloc_without_abort,
+                      *align, CADR(errmsg), CLEN(errmsg));
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(PTR_CALLOC04, ptr_calloc04)(__NELEM_T *nelem, __INT_T *kind,
@@ -1418,16 +2322,40 @@ ENTF90(PTR_CALLOC04, ptr_calloc04)(__NELEM_T *nelem, __INT_T *kind,
                                    firsttime, align,
                                    CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
+void
+ENTF90(SH_PTR_CALLOC04, sh_ptr_calloc04)(int id, __NELEM_T *nelem, __INT_T *kind,
+                                   __INT_T *len, __STAT_T *stat,
+                                   char **pointer, __POINT_T *offset,
+                                   __INT_T *firsttime, __NELEM_T *align,
+                                   DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_PTR_CALLOC04A, sh_ptr_calloc04a)(id, nelem, kind,
+                                   len, stat,
+                                   pointer, offset,
+                                   firsttime, align,
+                                   CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
+void
+ENTF90(PTR_KCALLOC, ptr_kcalloc)(__INT8_T *nelem, __INT_T *kind,
+                                 __INT_T *len, __STAT_T *stat,
+                                 char **pointer, __POINT_T *offset,
+                                 DCHAR(base) DCLEN(base))
+{
+  (void)I8(__fort_kalloc)(
+      *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset, CADR(base), 0,
+      LOCAL_MODE ? __fort_calloc_without_abort : __fort_gcalloc_without_abort);
+}
 
 void
-ENTF90(PTR_KCALLOC, ptr_kcalloc)(__INT8_T *nelem, __INT_T *kind,
+ENTF90(SH_PTR_KCALLOC, sh_ptr_kcalloc)(int id, __INT8_T *nelem, __INT_T *kind,
                                  __INT_T *len, __STAT_T *stat,
                                  char **pointer, __POINT_T *offset,
                                  DCHAR(base) DCLEN(base))
 {
-  (void)I8(__fort_kalloc)(
-      *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset, CADR(base), 0,
-      LOCAL_MODE ? __fort_calloc_without_abort : __fort_gcalloc_without_abort);
+  (void)I8(__sh_fort_kalloc)(
+      id, *nelem, (dtype)*kind, (size_t)*len, stat, pointer, offset, CADR(base), 0,
+      LOCAL_MODE ? __sh_fort_calloc_without_abort : __sh_fort_gcalloc_without_abort);
 }
 
 /** \brief
@@ -1443,6 +2371,14 @@ I8(__fort_allocate)(int nelem, dtype kind, size_t len, char *base,
                          __fort_gmalloc_without_abort);
 }
 
+char *
+I8(__sh_fort_allocate)(int id, int nelem, dtype kind, size_t len, char *base,
+                    char **pointer, __POINT_T *offset)
+{
+  return I8(__sh_fort_alloc)(id, nelem, kind, len, NULL, pointer, offset, base, 0,
+                         __sh_fort_gmalloc_without_abort);
+}
+
 /** \brief
  * Allocate local array (may be different size on each processor),
  * return pointer and pointer-sized integer offset from base address.
@@ -1457,6 +2393,14 @@ I8(__fort_local_allocate)(int nelem, dtype kind, size_t len, char *base,
                          __fort_malloc_without_abort);
 }
 
+char *
+I8(__sh_fort_local_allocate)(int id, int nelem, dtype kind, size_t len, char *base,
+                          char **pointer, __POINT_T *offset)
+{
+  return I8(__sh_fort_alloc)(id, nelem, kind, len, NULL, pointer, offset, base, 0,
+                         __sh_fort_malloc_without_abort);
+}
+
 /** \brief
  * Allocate global array (must be same size on all processors), return
  * pointer and pointer-sized integer offset from base address.  offset
@@ -1470,6 +2414,14 @@ I8(__fort_kallocate)(long nelem, dtype kind, size_t len, char *base,
                           __fort_gmalloc_without_abort);
 }
 
+char *
+I8(__sh_fort_kallocate)(int id, long nelem, dtype kind, size_t len, char *base,
+                     char **pointer, __POINT_T *offset)
+{
+  return I8(__sh_fort_kalloc)(id, nelem, kind, len, NULL, pointer, offset, base, 0,
+                          __sh_fort_gmalloc_without_abort);
+}
+
 /** \brief
  * Allocate local array (may be different size on each processor),
  * return pointer and pointer-sized integer offset from base address.
@@ -1485,6 +2437,14 @@ I8(__fort_local_kallocate)(long nelem, dtype kind, size_t len, char *base,
                           __fort_malloc_without_abort);
 }
 
+char *
+I8(__sh_fort_local_kallocate)(int id, long nelem, dtype kind, size_t len, char *base,
+                           char **pointer, __POINT_T *offset)
+{
+  return I8(__sh_fort_kalloc)(id, nelem, kind, len, NULL, pointer, offset, base, 0,
+                          __sh_fort_malloc_without_abort);
+}
+
 /** \brief
  * Deallocate array using given 'free' function
  */
@@ -1521,6 +2481,39 @@ I8(__fort_dealloc)(char *area, __STAT_T *stat, void (*freefn)(void *))
   return NULL;
 }
 
+char *
+I8(__sh_fort_dealloc)(char *area, __STAT_T *stat, void (*freefn)(void *))
+{
+  ALLO_HDR *p, *q;
+  char msg[80];
+
+  ALLHDR();
+
+  if (!ISPRESENT(stat))
+    stat = NULL;
+  if (!ISPRESENT(area))
+    area = NULL;
+  if (area) {
+#if defined(DEBUG)
+    if (__fort_test & DEBUG_ALLO)
+      printf("%d dealloc p %p area %p\n", GET_DIST_LCPU, p, area);
+#endif
+    freefn(XYZZY(area));
+    if (stat)
+      *stat = 0;
+    return area;
+  }
+  if (stat)
+    *stat = 1;
+  else {
+    MP_P_STDIO;
+    sprintf(msg, "DEALLOCATE: memory at %p not allocated", area);
+    MP_V_STDIO;
+    __fort_abort(msg);
+  }
+  return NULL;
+}
+
 static char *
 I8(__fort_dealloc03)(char *area, __STAT_T *stat, void (*freefn)(void *),
                      char *errmsg, int errlen)
@@ -1565,6 +2558,50 @@ I8(__fort_dealloc03)(char *area, __STAT_T *stat, void (*freefn)(void *),
   return NULL;
 }
 
+static char *
+I8(__sh_fort_dealloc03)(char *area, __STAT_T *stat, void (*freefn)(void *),
+                     char *errmsg, int errlen)
+{
+  ALLO_HDR *p, *q;
+  char msg[80];
+
+  ALLHDR();
+
+  if (!ISPRESENT(stat))
+    stat = NULL;
+  if (!ISPRESENT(area))
+    area = NULL;
+  if (!ISPRESENT(errmsg))
+    errmsg = NULL;
+  if (area) {
+#if defined(DEBUG)
+    if (__fort_test & DEBUG_ALLO)
+      printf("%d dealloc p %p area %p\n", GET_DIST_LCPU, p, area);
+#endif
+    freefn(XYZZY(area));
+    return area;
+  }
+  if (stat) {
+    *stat = 1;
+    if (errmsg) {
+      int i;
+      char *mp;
+      MP_P_STDIO;
+      sprintf(msg, "Memory at %p not allocated", area);
+      mp = msg;
+      for (i = 0; i < errlen; i++)
+        errmsg[i] = (*mp ? *mp++ : ' ');
+      MP_V_STDIO;
+    }
+  } else {
+    MP_P_STDIO;
+    sprintf(msg, "DEALLOCATE: memory at %p not allocated", area);
+    MP_V_STDIO;
+    __fort_abort(msg);
+  }
+  return NULL;
+}
+
 /** \brief
  * F77 deallocate statement
  */
@@ -1592,6 +2629,15 @@ ENTF90(DEALLOCA, dealloca)(__STAT_T *stat, DCHAR(area) DCLEN64(area))
                           LOCAL_MODE ? __fort_free : __fort_gfree);
 }
 
+void
+ENTF90(SH_DEALLOCA, sh_dealloca)(__STAT_T *stat, DCHAR(area) DCLEN64(area))
+{
+  if (reuse_alloc(stat, CADR(area)))
+    return;
+  (void)I8(__sh_fort_dealloc)(CADR(area), stat,
+                          LOCAL_MODE ? __sh_fort_free : __sh_fort_gfree);
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(DEALLOC, dealloc)(__STAT_T *stat, DCHAR(area) DCLEN(area))
@@ -1599,6 +2645,12 @@ ENTF90(DEALLOC, dealloc)(__STAT_T *stat, DCHAR(area) DCLEN(area))
   ENTF90(DEALLOCA, dealloca)(stat, CADR(area), (__CLEN_T)CLEN(area));
 }
 
+void
+ENTF90(SH_DEALLOC, sh_dealloc)(__STAT_T *stat, DCHAR(area) DCLEN(area))
+{
+  ENTF90(SH_DEALLOCA, sh_dealloca)(stat, CADR(area), (__CLEN_T)CLEN(area));
+}
+
 void
 ENTF90(DEALLOC03A, dealloc03a)(__STAT_T *stat, char *area,
                              __INT_T *firsttime,
@@ -1612,6 +2664,19 @@ ENTF90(DEALLOC03A, dealloc03a)(__STAT_T *stat, char *area,
                             CADR(errmsg), CLEN(errmsg));
 }
 
+void
+ENTF90(SH_DEALLOC03A, sh_dealloc03a)(__STAT_T *stat, char *area,
+                             __INT_T *firsttime,
+                             DCHAR(errmsg) DCLEN64(errmsg))
+{
+  if (ISPRESENT(stat) && *firsttime)
+    *stat = 0;
+  if (reuse_alloc(stat, area))
+    return;
+  (void)I8(__sh_fort_dealloc03)(area, stat, LOCAL_MODE ? __fort_free : __fort_gfree,
+                            CADR(errmsg), CLEN(errmsg));
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(DEALLOC03, dealloc03)(__STAT_T *stat, char *area,
@@ -1623,6 +2688,16 @@ ENTF90(DEALLOC03, dealloc03)(__STAT_T *stat, char *area,
                              CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_DEALLOC03, sh_dealloc03)(__STAT_T *stat, char *area,
+                             __INT_T *firsttime,
+                             DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_DEALLOC03A, sh_dealloc03a)(stat, area,
+                             firsttime,
+                             CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 void
 ENTF90(DEALLOC_MBR, dealloc_mbr)(__STAT_T *stat, DCHAR(area) DCLEN(area))
 {
@@ -1632,6 +2707,15 @@ ENTF90(DEALLOC_MBR, dealloc_mbr)(__STAT_T *stat, DCHAR(area) DCLEN(area))
   }
 }
 
+void
+ENTF90(SH_DEALLOC_MBR, sh_dealloc_mbr)(__STAT_T *stat, DCHAR(area) DCLEN(area))
+{
+
+  if (I8(__fort_allocated)(CADR(area))) {
+    ENTF90(SH_DEALLOC, sh_dealloc)(stat, CADR(area), CLEN(area));
+  }
+}
+
 void
 ENTF90(DEALLOC_MBR03A, dealloc_mbr03a)(__STAT_T *stat, char *area,
                                           __INT_T *firsttime,
@@ -1643,6 +2727,17 @@ ENTF90(DEALLOC_MBR03A, dealloc_mbr03a)(__STAT_T *stat, char *area,
   }
 }
 
+void
+ENTF90(SH_DEALLOC_MBR03A, sh_dealloc_mbr03a)(__STAT_T *stat, char *area,
+                                          __INT_T *firsttime,
+                                          DCHAR(errmsg) DCLEN64(errmsg))
+{
+  if (I8(__fort_allocated)(area)) {
+    ENTF90(SH_DEALLOC03,sh_dealloc03)(stat, area, firsttime,
+                CADR(errmsg), CLEN(errmsg));
+  }
+}
+
 /* 32 bit CLEN version */
 void
 ENTF90(DEALLOC_MBR03, dealloc_mbr03)(__STAT_T *stat, char *area,
@@ -1653,12 +2748,27 @@ ENTF90(DEALLOC_MBR03, dealloc_mbr03)(__STAT_T *stat, char *area,
                                           CADR(errmsg), (__CLEN_T)CLEN(errmsg));
 }
 
+void
+ENTF90(SH_DEALLOC_MBR03, sh_dealloc_mbr03)(__STAT_T *stat, char *area,
+                                          __INT_T *firsttime,
+                                          DCHAR(errmsg) DCLEN(errmsg))
+{
+  ENTF90(SH_DEALLOC_MBR03A, sh_dealloc_mbr03a)(stat, area, firsttime,
+                                          CADR(errmsg), (__CLEN_T)CLEN(errmsg));
+}
+
 void
 ENTF90(DEALLOCX, deallocx)(__STAT_T *stat, char **area)
 {
   (void)I8(__fort_dealloc)(*area, stat, LOCAL_MODE ? __fort_free : __fort_gfree);
 }
 
+void
+ENTF90(SH_DEALLOCX, sh_deallocx)(__STAT_T *stat, char **area)
+{
+  (void)I8(__sh_fort_dealloc)(*area, stat, LOCAL_MODE ? __fort_free : __fort_gfree);
+}
+
 /** \brief
  * deallocate global array
  */
@@ -1668,6 +2778,12 @@ I8(__fort_deallocate)(char *area)
   (void)I8(__fort_dealloc)(area, NULL, __fort_gfree);
 }
 
+void
+I8(__sh_fort_deallocate)(char *area)
+{
+  (void)I8(__sh_fort_dealloc)(area, NULL, __fort_gfree);
+}
+
 /** \brief
  * deallocate local array
  */
@@ -1678,6 +2794,12 @@ I8(__fort_local_deallocate)(char *area)
   (void)I8(__fort_dealloc)(area, NULL, __fort_free);
 }
 
+void
+I8(__sh_fort_local_deallocate)(char *area)
+{
+  (void)I8(__sh_fort_dealloc)(area, NULL, __sh_fort_free);
+}
+
 static size_t AUTO_ALN_MINSZ = 128000;
 static size_t AUTO_ALN_UNIT = 64;
 static size_t AUTO_ALN_MAXADJ = 4096;
@@ -1728,6 +2850,52 @@ I8(__auto_alloc)(__NELEM_T nelem, __INT_T sz,
   return area;
 }
 
+static void *
+I8(__sh_auto_alloc)(int id, __NELEM_T nelem, __INT_T sz,
+                    void *(*mallocroutine)(int, size_t))
+{
+  char *p, *area;
+  size_t size, need;
+  char msg[80];
+
+#define AUTO_ALN_THRESH (AUTO_ALN_MAXADJ / AUTO_ALN_UNIT)
+  static int aln_n = 0;
+  int myaln;
+
+  if (nelem > 0)
+    need = nelem * sz;
+  else
+    need = 0;
+
+  size = ((need + (ASZ - 1)) & ~(ASZ - 1)) + AUTOASZ; /* quad-alignment */
+
+  if (size > AUTO_ALN_MINSZ) {
+    myaln = aln_n;
+    size += AUTO_ALN_UNIT * myaln;
+    if (aln_n < AUTO_ALN_THRESH)
+      aln_n++;
+    else
+      aln_n = 0;
+  }
+
+  p = (char *)(mallocroutine)(id, size);
+  if (p == NULL) {
+    MP_P_STDIO;
+    sprintf(msg, "ALLOCATE: %lu bytes requested; not enough memory", need);
+    MP_V_STDIO;
+    __fort_abort(msg);
+  }
+
+  area = (char *)p + AUTOASZ; /* quad-alignment */
+
+  if (size > AUTO_ALN_MINSZ)
+    area += AUTO_ALN_UNIT * myaln;
+
+  XYZZYP(area, p);
+
+  return area;
+}
+
 #ifndef DESC_I8
 /*
  * Simple globally visible by value auto_alloc;
@@ -1739,6 +2907,14 @@ ENTF90(AUTO_ALLOCV, auto_allocv)(__NELEM_T nelem, int sz)
   p = I8(__auto_alloc)(nelem, sz, malloc);
   return p;
 }
+
+void *
+ENTF90(SH_AUTO_ALLOCV, sh_auto_allocv)(int id, __NELEM_T nelem, int sz)
+{
+  void *p;
+  p = I8(__sh_auto_alloc)(id, nelem, sz, malloc);
+  return p;
+}
 #endif
 
 void *
@@ -1750,6 +2926,15 @@ ENTF90(AUTO_ALLOC, auto_alloc)(__INT_T *nelem, __INT_T *sz)
   return p;
 }
 
+void *
+ENTF90(SH_AUTO_ALLOC, sh_auto_alloc)(int id, __INT_T *nelem, __INT_T *sz)
+{
+  void *p;
+
+  p = I8(__sh_auto_alloc)(id, *nelem, *sz, malloc);
+  return p;
+}
+
 void *
 ENTF90(AUTO_ALLOC04, auto_alloc04)(__NELEM_T *nelem, __INT_T *sz)
 {
@@ -1759,6 +2944,15 @@ ENTF90(AUTO_ALLOC04, auto_alloc04)(__NELEM_T *nelem, __INT_T *sz)
   return p;
 }
 
+void *
+ENTF90(SH_AUTO_ALLOC04, sh_auto_alloc04)(int id, __NELEM_T *nelem, __INT_T *sz)
+{
+  void *p;
+
+  p = I8(__sh_auto_alloc)(id, *nelem, *sz, malloc);
+  return p;
+}
+
 void *
 ENTF90(AUTO_CALLOC, auto_calloc)(__INT_T *nelem, __INT_T *sz)
 {
@@ -1774,6 +2968,21 @@ ENTF90(AUTO_CALLOC, auto_calloc)(__INT_T *nelem, __INT_T *sz)
   return p;
 }
 
+void *
+ENTF90(SH_AUTO_CALLOC, sh_auto_calloc)(int id, __INT_T *nelem, __INT_T *sz)
+{
+  size_t size;
+  void *p;
+
+  p = I8(__sh_auto_alloc)(id, *nelem, *sz, malloc);
+  if (p && *nelem > 0) {
+    size = *nelem * *sz;
+    memset(p, 0, size);
+  }
+
+  return p;
+}
+
 void *
 ENTF90(AUTO_CALLOC04, auto_calloc04)(__NELEM_T *nelem, __INT_T *sz)
 {
@@ -1789,9 +2998,27 @@ ENTF90(AUTO_CALLOC04, auto_calloc04)(__NELEM_T *nelem, __INT_T *sz)
   return p;
 }
 
+void *
+ENTF90(SH_AUTO_CALLOC04, sh_auto_calloc04)(int id, __NELEM_T *nelem, __INT_T *sz)
+{
+  size_t size;
+  void *p;
+
+  p = I8(__sh_auto_alloc)(id, *nelem, *sz, malloc);
+  if (p && *nelem > 0) {
+    size = *nelem * *sz;
+    memset(p, 0, size);
+  }
+
+  return p;
+}
+
 void
 ENTF90(AUTO_DEALLOC, auto_dealloc)(void *area) { free(XYZZY(area)); }
 
+void
+ENTF90(SH_AUTO_DEALLOC, sh_auto_dealloc)(void *area) { sh_free(XYZZY(area)); }
+
 #if defined(DEBUG)
 void
 ENTRY(__FTN_ALLOC_DUMP, __ftn_alloc_dump)()
diff --git a/runtime/flang/fioMacros.h b/runtime/flang/fioMacros.h
index 104c947b..6a185b74 100644
--- a/runtime/flang/fioMacros.h
+++ b/runtime/flang/fioMacros.h
@@ -1632,6 +1632,33 @@ void __fort_gfree(void *ptr);
 
 void *__fort_gsbrk(int n);
 
+/* SICM functions */
+char *I8(__sh_fort_alloc)(int id, __INT_T nelem, dtype kind,
+                           size_t len, __STAT_T *stat,
+                           char **pointer, __POINT_T *offset, char *base, int check,
+                           void *(*mallocfn)(int, size_t));
+char *I8(__sh_fort_allocate)(int id, int nelem, dtype kind, 
+                              size_t len, char *base,
+                              char **pointer, __POINT_T *offset);
+char *I8(__sh_fort_local_allocate)(int id, int nelem, 
+                                    dtype kind, size_t len, char *base,
+                                    char **pointer, __POINT_T *offset);
+char *I8(__sh_fort_dealloc)(char *area, __STAT_T *stat, void (*freefn)(void *));
+void I8(__sh_fort_deallocate)(char *area);
+void I8(__sh_fort_local_deallocate)(char *area);
+void *__sh_fort_malloc_without_abort(int id, size_t n);
+void *__sh_fort_calloc_without_abort(int id, size_t n);
+void *__sh_fort_malloc(int id, size_t n);
+void *__sh_fort_realloc(int id, void *ptr, size_t n);
+void *__sh_fort_calloc(int id, size_t n, size_t s);
+void __sh_fort_free(void *ptr);
+void *__sh_fort_gmalloc_without_abort(int id, size_t n);
+void *__sh_fort_gcalloc_without_abort(int id, size_t n);
+void *__sh_fort_gmalloc(int id, size_t n);
+void *__sh_fort_grealloc(int id, void *ptr, size_t n);
+void *__sh_fort_gcalloc(int id, size_t n, size_t s);
+void __sh_fort_gfree(void *ptr);
+
 /* group */
 
 struct cgrp {
diff --git a/runtime/flang/malloc.c b/runtime/flang/malloc.c
index b6716449..7c409f10 100644
--- a/runtime/flang/malloc.c
+++ b/runtime/flang/malloc.c
@@ -28,6 +28,11 @@ extern void *shmalloc(size_t);
 
 #define ZIP ((char *)15L)
 
+void *sh_alloc(int id, size_t n);
+void sh_free(void *ptr);
+void *sh_realloc(int id, void *ptr, size_t size);
+void *ben_calloc(int id, size_t nmemb, size_t size);
+
 /* malloc */
 
 void *
@@ -43,6 +48,19 @@ __fort_malloc_without_abort(size_t n)
   return p;
 }
 
+void *
+__sh_fort_malloc_without_abort(int id, size_t n)
+{
+  char *p;
+
+  if (n == 0)
+    return ZIP;
+  p = sh_alloc(id, n);
+  if (__fort_zmem && (p != NULL))
+    memset(p, '\0', n);
+  return p;
+}
+
 void *
 __fort_malloc(size_t n)
 {
@@ -54,6 +72,17 @@ __fort_malloc(size_t n)
   return p;
 }
 
+void *
+__sh_fort_malloc(int id, size_t n)
+{
+  char *p;
+
+  p = __sh_fort_malloc_without_abort(id, n);
+  if (p == (char *)0)
+    __fort_abort("__fort_malloc: not enough memory");
+  return p;
+}
+
 /* realloc */
 
 void *
@@ -80,6 +109,30 @@ __fort_realloc(void *ptr, size_t n)
   return (p);
 }
 
+void *
+__sh_fort_realloc(int id, void *ptr, size_t n)
+{
+  char *p;
+
+  if (ptr == (char *)0 | ptr == ZIP) {
+    if (n == 0)
+      return ZIP;
+    p = sh_alloc(id, n);
+    if (__fort_zmem && (p != NULL))
+      memset(p, '\0', n);
+  } else {
+    if (n == 0) {
+      sh_free(ptr);
+      return ZIP;
+    }
+    p = sh_realloc(id, ptr, n);
+  }
+  if (p == (char *)0) {
+    __fort_abort("__fort_realloc: not enough memory");
+  }
+  return (p);
+}
+
 /* calloc */
 
 void *
@@ -95,6 +148,19 @@ __fort_calloc_without_abort(size_t n)
   return p;
 }
 
+void *
+__sh_fort_calloc_without_abort(int id, size_t n)
+{
+  char *p;
+
+  if (n == 0)
+    return ZIP;
+  p = sh_alloc(id, n);
+  if (p != NULL)
+    memset(p, '\0', n);
+  return p;
+}
+
 void *
 __fort_calloc(size_t n, size_t s)
 {
@@ -109,6 +175,20 @@ __fort_calloc(size_t n, size_t s)
   return (p);
 }
 
+void *
+__sh_fort_calloc(int id, size_t n, size_t s)
+{
+  char *p;
+
+  if (n == 0 | s == 0)
+    return ZIP;
+  p = sh_calloc(id, n, s);
+  if (p == (char *)0) {
+    __fort_abort("__fort_calloc: not enough memory");
+  }
+  return (p);
+}
+
 /* free */
 
 void
@@ -119,6 +199,14 @@ __fort_free(void *ptr)
   }
 }
 
+void
+__sh_fort_free(void *ptr)
+{
+  if (ptr != (char *)0 & ptr != ZIP) {
+    sh_free(ptr);
+  }
+}
+
 /* ================= pseudo-global heap routines ================= */
 
 /* stubs for global shared memory (mmapped) allocation calls */
@@ -129,33 +217,68 @@ __fort_gmalloc_without_abort(size_t n)
   return __fort_malloc_without_abort(n);
 }
 
+void *
+__sh_fort_gmalloc_without_abort(int id, size_t n)
+{
+  return __sh_fort_malloc_without_abort(id, n);
+}
+
 void *
 __fort_gmalloc(size_t n)
 {
   return __fort_malloc(n);
 }
 
+void *
+__sh_fort_gmalloc(int id, size_t n)
+{
+  return __sh_fort_malloc(id, n);
+}
+
 void *
 __fort_grealloc(void *ptr, size_t n)
 {
   return __fort_realloc(ptr, n);
 }
 
+void *
+__sh_fort_grealloc(int id, void *ptr, size_t n)
+{
+  return __sh_fort_realloc(id, ptr, n);
+}
+
 void *
 __fort_gcalloc_without_abort(size_t n)
 {
   return __fort_calloc_without_abort(n);
 }
 
+void *
+__sh_fort_gcalloc_without_abort(int id, size_t n)
+{
+  return __sh_fort_calloc_without_abort(id, n);
+}
+
 void *
 __fort_gcalloc(size_t n, size_t s)
 {
   return __fort_calloc(n, s);
 }
 
+void *
+__sh_fort_gcalloc(int id, size_t n, size_t s)
+{
+  return __sh_fort_calloc(id, n, s);
+}
+
 void
 __fort_gfree(void *ptr)
 {
   __fort_free(ptr);
 }
 
+void
+__sh_fort_gfree(void *ptr)
+{
+  __sh_fort_free(ptr);
+}
